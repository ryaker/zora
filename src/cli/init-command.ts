/**
 * `zora init` — Interactive setup wizard.
 *
 * Generates ~/.zora/config.toml, policy.toml, SOUL.md,
 * and scaffolds the directory structure.
 */

import type { Command } from 'commander';
import path from 'node:path';
import os from 'node:os';
import fs from 'node:fs';
import * as clack from '@clack/prompts';
import { stringify as stringifyTOML, parse as parseTOML } from 'smol-toml';
import { PRESETS, TOOL_STACKS, PRESET_DESCRIPTIONS } from './presets.js';
import { runDoctorChecks } from './doctor.js';
import type { DoctorResult } from './doctor.js';
import type { PresetName } from './presets.js';
import type { ZoraPolicy } from '../types.js';

const ZORA_DIR = path.join(os.homedir(), '.zora');

/**
 * Directories to scaffold under ~/.zora/
 */
const SCAFFOLD_DIRS = [
  '',             // ~/.zora/ itself
  'workspace',
  'memory',
  'memory/daily',
  'memory/items',
  'memory/categories',
  'audit',
];

const SOUL_TEMPLATE = `# Zora — Soul File

You are Zora, a long-running autonomous personal AI agent.

## Core Principles
- Be helpful, honest, and careful.
- Always respect the policy file boundaries.
- Ask for clarification when uncertain.
- Keep audit logs for all actions.

## Owner Preferences
- (Add your preferences here)
`;

/**
 * Generate policy.toml content from a preset, dev path, denied paths, and tool stacks.
 */
export function generatePolicyToml(
  preset: PresetName,
  devPath: string,
  deniedPaths: string[],
  toolStacks: string[],
): string {
  const base = structuredClone(PRESETS[preset]);

  // Replace ~/Projects with user's dev path
  base.filesystem.allowed_paths = base.filesystem.allowed_paths.map(
    (p) => (p === '~/Projects' ? devPath : p),
  );

  // Merge additional denied paths (deduplicate)
  const allDenied = new Set([...base.filesystem.denied_paths, ...deniedPaths]);
  base.filesystem.denied_paths = [...allDenied];

  // Merge tool stack commands into allowed_commands (only if shell isn't deny_all)
  if (base.shell.mode !== 'deny_all') {
    const extraCommands = toolStacks.flatMap((stack) => TOOL_STACKS[stack] ?? []);
    const allCommands = new Set([...base.shell.allowed_commands, ...extraCommands]);
    base.shell.allowed_commands = [...allCommands];
  }

  return policyToToml(base);
}

/**
 * Serialize a ZoraPolicy to TOML string.
 */
function policyToToml(policy: ZoraPolicy): string {
  // smol-toml stringify works with plain objects
  return stringifyTOML(policy as unknown as Record<string, unknown>);
}

/**
 * Generate config.toml content based on doctor results.
 */
export function generateConfigToml(doctor: DoctorResult): string {
  const providers: string[] = [];
  let rank = 1;

  if (doctor.claude.found) {
    providers.push(`[[providers]]
name = "claude"
type = "claude-sdk"
rank = ${rank}
capabilities = ["reasoning", "coding", "creative"]
cost_tier = "included"
enabled = true
auth_method = "mac_session"
model = "claude-sonnet-4-5"
max_turns = 200`);
    rank++;
  }

  if (doctor.gemini.found) {
    providers.push(`[[providers]]
name = "gemini"
type = "gemini-cli"
rank = ${rank}
capabilities = ["search", "structured-data", "large-context", "coding"]
cost_tier = "included"
enabled = true
auth_method = "workspace_sso"
cli_path = "gemini"
model = "gemini-2.5-pro"
max_turns = 100`);
  }

  const providerBlock = providers.length > 0
    ? providers.join('\n\n')
    : `# No providers detected. Add one manually:
# [[providers]]
# name = "claude"
# type = "claude-sdk"
# rank = 1
# capabilities = ["reasoning", "coding"]
# cost_tier = "included"
# enabled = true`;

  return `# Zora Configuration — generated by \`zora init\`

[agent]
name = "zora"
workspace = "~/.zora/workspace"
max_parallel_jobs = 3
default_timeout = "2h"
heartbeat_interval = "30m"
log_level = "info"

[agent.identity]
soul_file = "~/.zora/SOUL.md"

[agent.resources]
cpu_throttle_percent = 80
memory_limit_mb = 4096
throttle_check_interval = "10s"

${providerBlock}

[routing]
mode = "respect_ranking"

[failover]
enabled = true
auto_handoff = true
max_handoff_context_tokens = 50000
retry_after_cooldown = true
max_retries = 3
checkpoint_on_auth_failure = true
notify_on_failover = true

[memory]
long_term_file = "~/.zora/memory/MEMORY.md"
daily_notes_dir = "~/.zora/memory/daily"
items_dir = "~/.zora/memory/items"
categories_dir = "~/.zora/memory/categories"
context_days = 7
max_context_items = 20
max_category_summaries = 5
auto_extract_interval = 10

[security]
policy_file = "~/.zora/policy.toml"
audit_log = "~/.zora/audit/audit.jsonl"
audit_hash_chain = true
audit_single_writer = true
integrity_check = true
integrity_interval = "30m"
integrity_includes_tool_registry = true
leak_detection = true
sanitize_untrusted_content = true
jit_secret_decryption = true

[steering]
enabled = true
poll_interval = "5s"
dashboard_port = 7070
notify_on_flag = true
flag_timeout = "10m"
auto_approve_low_risk = true
always_flag_irreversible = true

[notifications]
enabled = true
on_task_complete = true
on_error = true
on_failover = true
on_auth_expiry = true
on_all_providers_down = true
`;
}

/**
 * Scaffold the ~/.zora directory structure.
 */
export function scaffoldDirectories(baseDir: string): void {
  for (const dir of SCAFFOLD_DIRS) {
    const fullPath = path.join(baseDir, dir);
    if (!fs.existsSync(fullPath)) {
      fs.mkdirSync(fullPath, { recursive: true });
    }
  }
}

/**
 * Write the SOUL.md template if it doesn't exist.
 */
export function writeSoulFile(baseDir: string): void {
  const soulPath = path.join(baseDir, 'SOUL.md');
  if (!fs.existsSync(soulPath)) {
    fs.writeFileSync(soulPath, SOUL_TEMPLATE, 'utf-8');
  }
}

/**
 * Detect a sensible default dev path.
 */
function detectDevPath(): string {
  const candidates = [
    path.join(os.homedir(), 'Dev'),
    path.join(os.homedir(), 'Projects'),
    path.join(os.homedir(), 'Developer'),
    path.join(os.homedir(), 'Code'),
    path.join(os.homedir(), 'src'),
  ];
  for (const candidate of candidates) {
    if (fs.existsSync(candidate)) {
      return candidate.replace(os.homedir(), '~');
    }
  }
  return '~/Projects';
}

/**
 * Run the interactive wizard.
 */
async function runWizard(opts: {
  preset?: string;
  devPath?: string;
  yes?: boolean;
  force?: boolean;
}): Promise<void> {
  const configPath = path.join(ZORA_DIR, 'config.toml');
  const policyPath = path.join(ZORA_DIR, 'policy.toml');

  // Guard: refuse to overwrite unless --force
  if (!opts.force && (fs.existsSync(configPath) || fs.existsSync(policyPath))) {
    const existing = [
      fs.existsSync(configPath) ? 'config.toml' : null,
      fs.existsSync(policyPath) ? 'policy.toml' : null,
    ].filter(Boolean).join(' and ');
    console.error(`Existing ${existing} found in ${ZORA_DIR}.`);
    console.error('Use --force to overwrite.');
    process.exit(1);
  }

  clack.intro('Welcome to Zora');

  // Doctor checks
  const spin = clack.spinner();
  spin.start('Checking environment...');
  const doctor = await runDoctorChecks();
  spin.stop('Environment checked');

  // Show doctor results
  const nodeStatus = doctor.node.found ? `Node.js ${doctor.node.version}` : 'Node.js < 20 (upgrade recommended)';
  const claudeStatus = doctor.claude.found ? `Claude CLI (${doctor.claude.path})` : 'Claude CLI (not found)';
  const geminiStatus = doctor.gemini.found ? `Gemini CLI (${doctor.gemini.path})` : 'Gemini CLI (not found)';
  clack.note(
    [nodeStatus, claudeStatus, geminiStatus].join('\n'),
    'Detected tools',
  );

  // Preset selection
  let preset: PresetName;
  if (opts.preset && (opts.preset === 'safe' || opts.preset === 'balanced' || opts.preset === 'power')) {
    preset = opts.preset;
  } else if (opts.yes) {
    preset = 'balanced';
  } else {
    const presetChoice = await clack.select({
      message: 'Choose a security preset:',
      options: [
        { value: 'safe', label: 'Safe', hint: PRESET_DESCRIPTIONS.safe },
        { value: 'balanced', label: 'Balanced', hint: PRESET_DESCRIPTIONS.balanced },
        { value: 'power', label: 'Power', hint: PRESET_DESCRIPTIONS.power },
      ],
    });
    if (clack.isCancel(presetChoice)) {
      clack.cancel('Setup cancelled.');
      process.exit(0);
    }
    preset = presetChoice as PresetName;
  }

  // Dev path
  let devPath: string;
  const defaultDevPath = detectDevPath();
  if (opts.devPath) {
    devPath = opts.devPath.replace(os.homedir(), '~');
  } else if (opts.yes) {
    devPath = defaultDevPath;
  } else {
    const devPathInput = await clack.text({
      message: 'Where do you code?',
      placeholder: defaultDevPath,
      defaultValue: defaultDevPath,
    });
    if (clack.isCancel(devPathInput)) {
      clack.cancel('Setup cancelled.');
      process.exit(0);
    }
    devPath = (devPathInput as string).replace(os.homedir(), '~');
  }

  // Denied paths
  let deniedPaths: string[];
  if (opts.yes) {
    deniedPaths = ['~/.ssh', '~/.gnupg', '~/.aws'];
  } else {
    const deniedChoices = await clack.multiselect({
      message: 'Which paths should be denied? (pre-selected are recommended)',
      options: [
        { value: '~/.ssh', label: '~/.ssh', hint: 'SSH keys' },
        { value: '~/.gnupg', label: '~/.gnupg', hint: 'GPG keys' },
        { value: '~/.aws', label: '~/.aws', hint: 'AWS credentials' },
        { value: '~/Documents', label: '~/Documents' },
        { value: '~/Desktop', label: '~/Desktop' },
        { value: '~/Downloads', label: '~/Downloads' },
        { value: '~/Library', label: '~/Library', hint: 'macOS system' },
      ],
      initialValues: ['~/.ssh', '~/.gnupg', '~/.aws'],
    });
    if (clack.isCancel(deniedChoices)) {
      clack.cancel('Setup cancelled.');
      process.exit(0);
    }
    deniedPaths = deniedChoices as string[];
  }

  // Tool stacks
  let toolStacks: string[];
  if (opts.yes) {
    // Auto-detect based on doctor
    toolStacks = ['general'];
    if (doctor.node.found) toolStacks.push('node');
  } else {
    const stackChoices = await clack.multiselect({
      message: 'Which tool stacks do you use?',
      options: [
        { value: 'node', label: 'Node.js', hint: 'node, npm, npx, tsc, vitest' },
        { value: 'python', label: 'Python', hint: 'python3, pip, pip3' },
        { value: 'rust', label: 'Rust', hint: 'cargo, rustc, rustup' },
        { value: 'go', label: 'Go', hint: 'go' },
        { value: 'general', label: 'General CLI', hint: 'ls, pwd, cat, head, grep, find, etc.' },
      ],
      initialValues: ['node', 'general'],
    });
    if (clack.isCancel(stackChoices)) {
      clack.cancel('Setup cancelled.');
      process.exit(0);
    }
    toolStacks = stackChoices as string[];
  }

  // Confirm
  if (!opts.yes) {
    const summary = [
      `Preset:      ${preset}`,
      `Dev path:    ${devPath}`,
      `Denied:      ${deniedPaths.join(', ')}`,
      `Tool stacks: ${toolStacks.join(', ')}`,
      `Providers:   ${[doctor.claude.found ? 'Claude' : null, doctor.gemini.found ? 'Gemini' : null].filter(Boolean).join(', ') || 'none detected'}`,
    ].join('\n');
    clack.note(summary, 'Summary');

    const confirmed = await clack.confirm({
      message: 'Write configuration files?',
    });
    if (clack.isCancel(confirmed) || !confirmed) {
      clack.cancel('Setup cancelled.');
      process.exit(0);
    }
  }

  // Generate files
  const policyToml = generatePolicyToml(preset, devPath, deniedPaths, toolStacks);
  const configToml = generateConfigToml(doctor);

  // Validate generated TOML parses cleanly
  try {
    parseTOML(policyToml);
  } catch (e) {
    console.error('Generated policy.toml is invalid TOML:', e);
    process.exit(1);
  }
  try {
    parseTOML(configToml);
  } catch (e) {
    console.error('Generated config.toml is invalid TOML:', e);
    process.exit(1);
  }

  // Scaffold and write
  scaffoldDirectories(ZORA_DIR);
  writeSoulFile(ZORA_DIR);
  fs.writeFileSync(policyPath, policyToml, 'utf-8');
  fs.writeFileSync(configPath, configToml, 'utf-8');

  clack.outro('Zora is ready! Run `zora ask "hello"` to get started.');
}

/**
 * Register the `zora init` command on the commander program.
 */
export function registerInitCommand(program: Command): void {
  program
    .command('init')
    .description('Set up Zora — generate config, policy, and directory structure')
    .option('--preset <preset>', 'Security preset: safe, balanced, or power')
    .option('--dev-path <path>', 'Path to your code directory')
    .option('-y, --yes', 'Accept all defaults (non-interactive)')
    .option('--force', 'Overwrite existing config files')
    .action(async (opts) => {
      await runWizard(opts);
    });
}
